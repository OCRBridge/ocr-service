"""Unit tests for EasyOCR hOCR XML generation."""

import xml.etree.ElementTree as ET

from src.utils.hocr import easyocr_to_hocr


class TestEasyOCRHocrStructure:
    """Test hOCR XML structure generated by EasyOCR."""

    def test_hocr_contains_standard_hierarchy(self):
        """Test that hOCR output has ocr_page → ocr_line → ocrx_word hierarchy."""
        # Mock EasyOCR results: (bbox, text, confidence)
        easyocr_results = [
            # Line 1: Two words at y=100
            ([[10, 100], [60, 100], [60, 130], [10, 130]], "Hello", 0.95),
            ([[70, 100], [130, 100], [130, 130], [70, 130]], "World", 0.93),
            # Line 2: One word at y=150
            ([[10, 150], [60, 150], [60, 180], [10, 180]], "Test", 0.91),
        ]

        hocr_xml = easyocr_to_hocr(easyocr_results, 800, 600)

        # Parse XML (skip DOCTYPE for easier parsing)
        xml_content = hocr_xml.split('\n', 2)[2]  # Skip XML declaration and DOCTYPE
        root = ET.fromstring(xml_content)

        # Find ocr_page
        body = root.find('.//{http://www.w3.org/1999/xhtml}body')
        page = body.find('.//{http://www.w3.org/1999/xhtml}div[@class="ocr_page"]')
        assert page is not None, "ocr_page element not found"

        # Find ocr_line elements
        lines = page.findall('.//{http://www.w3.org/1999/xhtml}span[@class="ocr_line"]')
        assert len(lines) == 2, f"Expected 2 ocr_line elements, found {len(lines)}"

        # Find ocrx_word elements
        words_in_page = page.findall('.//{http://www.w3.org/1999/xhtml}span[@class="ocrx_word"]')
        assert len(words_in_page) == 3, f"Expected 3 ocrx_word elements, found {len(words_in_page)}"

        # Verify words are inside lines, not direct children of page
        for line in lines:
            words_in_line = line.findall('.//{http://www.w3.org/1999/xhtml}span[@class="ocrx_word"]')
            assert len(words_in_line) > 0, "ocr_line should contain ocrx_word elements"

    def test_hocr_line_has_correct_attributes(self):
        """Test that ocr_line elements have correct attributes."""
        easyocr_results = [
            ([[10, 100], [60, 100], [60, 130], [10, 130]], "Test", 0.95),
        ]

        hocr_xml = easyocr_to_hocr(easyocr_results, 800, 600)

        # Parse XML
        xml_content = hocr_xml.split('\n', 2)[2]
        root = ET.fromstring(xml_content)

        # Find first ocr_line
        line = root.find('.//{http://www.w3.org/1999/xhtml}span[@class="ocr_line"]')
        assert line is not None, "ocr_line element not found"

        # Check ID attribute
        line_id = line.get('id')
        assert line_id is not None, "ocr_line should have id attribute"
        assert line_id.startswith('line_'), f"Line id should start with 'line_', got {line_id}"

        # Check title attribute with bbox
        title = line.get('title')
        assert title is not None, "ocr_line should have title attribute"
        assert 'bbox' in title, "ocr_line title should contain bbox"

    def test_hocr_words_sorted_left_to_right_within_line(self):
        """Test that words within a line are sorted left to right."""
        # Create words on same line (same y) but different x positions
        easyocr_results = [
            # Words deliberately out of order (by x position)
            ([[70, 100], [130, 100], [130, 130], [70, 130]], "Second", 0.93),
            ([[10, 100], [60, 100], [60, 130], [10, 130]], "First", 0.95),
            ([[140, 100], [200, 100], [200, 130], [140, 130]], "Third", 0.91),
        ]

        hocr_xml = easyocr_to_hocr(easyocr_results, 800, 600)

        # Parse XML
        xml_content = hocr_xml.split('\n', 2)[2]
        root = ET.fromstring(xml_content)

        # Find first ocr_line
        line = root.find('.//{http://www.w3.org/1999/xhtml}span[@class="ocr_line"]')
        words = line.findall('.//{http://www.w3.org/1999/xhtml}span[@class="ocrx_word"]')

        # Extract word text
        word_texts = [word.text for word in words]
        assert word_texts == ["First", "Second", "Third"], f"Words should be sorted left to right, got {word_texts}"

    def test_hocr_line_grouping_by_vertical_position(self):
        """Test that words are correctly grouped into lines by vertical position."""
        # Create words on different lines (different y positions)
        easyocr_results = [
            # Line 1 at y=100
            ([[10, 100], [60, 100], [60, 130], [10, 130]], "Line1Word1", 0.95),
            ([[70, 102], [130, 102], [130, 132], [70, 132]], "Line1Word2", 0.93),  # Slightly offset but same line
            # Line 2 at y=200 (far enough to be different line)
            ([[10, 200], [60, 200], [60, 230], [10, 230]], "Line2Word1", 0.91),
        ]

        hocr_xml = easyocr_to_hocr(easyocr_results, 800, 600)

        # Parse XML
        xml_content = hocr_xml.split('\n', 2)[2]
        root = ET.fromstring(xml_content)

        # Find all ocr_line elements
        lines = root.findall('.//{http://www.w3.org/1999/xhtml}span[@class="ocr_line"]')
        assert len(lines) == 2, f"Expected 2 lines, got {len(lines)}"

        # Check first line has 2 words
        line1_words = lines[0].findall('.//{http://www.w3.org/1999/xhtml}span[@class="ocrx_word"]')
        assert len(line1_words) == 2, f"Line 1 should have 2 words, got {len(line1_words)}"

        # Check second line has 1 word
        line2_words = lines[1].findall('.//{http://www.w3.org/1999/xhtml}span[@class="ocrx_word"]')
        assert len(line2_words) == 1, f"Line 2 should have 1 word, got {len(line2_words)}"

    def test_hocr_line_bbox_encompasses_all_words(self):
        """Test that line bounding box encompasses all words in the line."""
        easyocr_results = [
            ([[10, 100], [60, 100], [60, 130], [10, 130]], "First", 0.95),
            ([[70, 105], [130, 105], [130, 135], [70, 135]], "Second", 0.93),
        ]

        hocr_xml = easyocr_to_hocr(easyocr_results, 800, 600)

        # Parse XML
        xml_content = hocr_xml.split('\n', 2)[2]
        root = ET.fromstring(xml_content)

        # Find line
        line = root.find('.//{http://www.w3.org/1999/xhtml}span[@class="ocr_line"]')
        line_title = line.get('title')

        # Extract line bbox
        import re
        line_bbox_match = re.search(r'bbox (\d+) (\d+) (\d+) (\d+)', line_title)
        assert line_bbox_match, "Line should have bbox in title"
        line_x_min, line_y_min, line_x_max, line_y_max = map(int, line_bbox_match.groups())

        # Line bbox should be: x_min=10, y_min=100, x_max=130, y_max=135
        assert line_x_min == 10, f"Line x_min should be 10, got {line_x_min}"
        assert line_y_min == 100, f"Line y_min should be 100, got {line_y_min}"
        assert line_x_max == 130, f"Line x_max should be 130, got {line_x_max}"
        assert line_y_max == 135, f"Line y_max should be 135, got {line_y_max}"

    def test_hocr_word_confidence_converted_to_percentage(self):
        """Test that word confidence is correctly converted from 0.0-1.0 to 0-100."""
        easyocr_results = [
            ([[10, 100], [60, 100], [60, 130], [10, 130]], "Test", 0.95),
        ]

        hocr_xml = easyocr_to_hocr(easyocr_results, 800, 600)

        # Parse XML
        xml_content = hocr_xml.split('\n', 2)[2]
        root = ET.fromstring(xml_content)

        # Find word
        word = root.find('.//{http://www.w3.org/1999/xhtml}span[@class="ocrx_word"]')
        word_title = word.get('title')

        # Check confidence
        import re
        conf_match = re.search(r'x_wconf (\d+)', word_title)
        assert conf_match, "Word should have x_wconf in title"
        confidence = int(conf_match.group(1))
        assert confidence == 95, f"Confidence should be 95, got {confidence}"

    def test_hocr_empty_results_creates_valid_structure(self):
        """Test that empty EasyOCR results still create valid hOCR structure."""
        easyocr_results = []

        hocr_xml = easyocr_to_hocr(easyocr_results, 800, 600)

        # Should still have page element
        assert 'ocr_page' in hocr_xml, "Empty results should still create ocr_page"
        assert '800' in hocr_xml and '600' in hocr_xml, "Page dimensions should be in output"

        # Parse to verify valid XML
        xml_content = hocr_xml.split('\n', 2)[2]
        root = ET.fromstring(xml_content)
        page = root.find('.//{http://www.w3.org/1999/xhtml}div[@class="ocr_page"]')
        assert page is not None, "ocr_page element should exist even with no words"

    def test_hocr_special_characters_escaped(self):
        """Test that special XML characters in text are properly escaped."""
        easyocr_results = [
            ([[10, 100], [60, 100], [60, 130], [10, 130]], "<Test&>", 0.95),
        ]

        hocr_xml = easyocr_to_hocr(easyocr_results, 800, 600)

        # Should contain escaped characters
        assert '&lt;Test&amp;&gt;' in hocr_xml, "Special characters should be escaped"

        # Parse to verify valid XML
        xml_content = hocr_xml.split('\n', 2)[2]
        root = ET.fromstring(xml_content)
        word = root.find('.//{http://www.w3.org/1999/xhtml}span[@class="ocrx_word"]')
        assert word.text == "<Test&>", "Parsed text should match original"
